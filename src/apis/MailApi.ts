/* tslint:disable */
/* eslint-disable */
/**
 * Mail-in-a-Box
 * Mail-in-a-Box API HTTP specification.  # Introduction This API is documented in [**OpenAPI format**](http://spec.openapis.org/oas/v3.0.3). ([View the full HTTP specification](https://raw.githubusercontent.com/mail-in-a-box/mailinabox/api-spec/api/mailinabox.yml).)  All endpoints are relative to `https://{host}/admin` and are secured with [`Basic Access` authentication](https://en.wikipedia.org/wiki/Basic_access_authentication). If you have multi-factor authentication enabled, authentication with a `user:password` combination will fail unless a valid OTP is supplied via the `x-auth-token` header. Authentication via a `user:user_key` pair is possible without the header being present.
 *
 * The version of the OpenAPI document: 0.51.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
  MailAliasByDomain,
  MailAliasByDomainFromJSON,
  MailAliasByDomainToJSON,
  MailAliasesResponseFormat,
  MailAliasesResponseFormatFromJSON,
  MailAliasesResponseFormatToJSON,
  MailUserPrivilege,
  MailUserPrivilegeFromJSON,
  MailUserPrivilegeToJSON,
  MailUsersResponse,
  MailUsersResponseFromJSON,
  MailUsersResponseToJSON,
  MailUsersResponseFormat,
  MailUsersResponseFormatFromJSON,
  MailUsersResponseFormatToJSON,
} from '../models';

export interface AddMailUserRequest {
  email: string;
  password: string;
  privileges: MailUserPrivilege;
}

export interface AddMailUserPrivilegeRequest {
  email: string;
  privilege: MailUserPrivilege;
}

export interface GetMailAliasesRequest {
  format?: MailAliasesResponseFormat;
}

export interface GetMailUserPrivilegesRequest {
  email?: string;
}

export interface GetMailUsersRequest {
  format?: MailUsersResponseFormat;
}

export interface RemoveMailAliasRequest {
  address: string;
}

export interface RemoveMailUserRequest {
  email: string;
}

export interface RemoveMailUserPrivilegeRequest {
  email: string;
  privilege: MailUserPrivilege;
}

export interface SetMailUserPasswordRequest {
  email: string;
  password: string;
}

export interface UpsertMailAliasRequest {
  updateIfExists: number;
  address: string;
  forwardsTo: string;
  permittedSenders: string | null;
}

/**
 *
 */
export class MailApi extends runtime.BaseAPI {
  /**
   * Adds a new mail user.
   * Add mail user
   */
  async addMailUserRaw(
    requestParameters: AddMailUserRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (
      requestParameters.email === null ||
      requestParameters.email === undefined
    ) {
      throw new runtime.RequiredError(
        'email',
        'Required parameter requestParameters.email was null or undefined when calling addMailUser.'
      );
    }

    if (
      requestParameters.password === null ||
      requestParameters.password === undefined
    ) {
      throw new runtime.RequiredError(
        'password',
        'Required parameter requestParameters.password was null or undefined when calling addMailUser.'
      );
    }

    if (
      requestParameters.privileges === null ||
      requestParameters.privileges === undefined
    ) {
      throw new runtime.RequiredError(
        'privileges',
        'Required parameter requestParameters.privileges was null or undefined when calling addMailUser.'
      );
    }

    const queryParameters: runtime.HTTPQuery = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' +
        btoa(this.configuration.username + ':' + this.configuration.password);
    }
    const consumes: runtime.Consume[] = [
      { contentType: 'application/x-www-form-urlencoded' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.email !== undefined) {
      formParams.append('email', requestParameters.email as any);
    }

    if (requestParameters.password !== undefined) {
      formParams.append('password', requestParameters.password as any);
    }

    if (requestParameters.privileges !== undefined) {
      formParams.append('privileges', requestParameters.privileges as any);
    }

    const response = await this.request({
      path: `/mail/users/add`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: formParams,
    });

    const contentType = response.headers.get('content-type');
    const isJson = contentType && contentType.includes('application/json');
    return new runtime[isJson ? 'JSONApiResponse' : 'TextApiResponse'](
      response
    ) as any;
  }

  /**
   * Adds a new mail user.
   * Add mail user
   */
  async addMailUser(requestParameters: AddMailUserRequest): Promise<string> {
    const response = await this.addMailUserRaw(requestParameters);
    return await response.value();
  }

  /**
   * Adds a privilege to an existing mail user.
   * Add mail user privilege
   */
  async addMailUserPrivilegeRaw(
    requestParameters: AddMailUserPrivilegeRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (
      requestParameters.email === null ||
      requestParameters.email === undefined
    ) {
      throw new runtime.RequiredError(
        'email',
        'Required parameter requestParameters.email was null or undefined when calling addMailUserPrivilege.'
      );
    }

    if (
      requestParameters.privilege === null ||
      requestParameters.privilege === undefined
    ) {
      throw new runtime.RequiredError(
        'privilege',
        'Required parameter requestParameters.privilege was null or undefined when calling addMailUserPrivilege.'
      );
    }

    const queryParameters: runtime.HTTPQuery = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' +
        btoa(this.configuration.username + ':' + this.configuration.password);
    }
    const consumes: runtime.Consume[] = [
      { contentType: 'application/x-www-form-urlencoded' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.email !== undefined) {
      formParams.append('email', requestParameters.email as any);
    }

    if (requestParameters.privilege !== undefined) {
      formParams.append('privilege', requestParameters.privilege as any);
    }

    const response = await this.request({
      path: `/mail/users/privileges/add`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: formParams,
    });

    const contentType = response.headers.get('content-type');
    const isJson = contentType && contentType.includes('application/json');
    return new runtime[isJson ? 'JSONApiResponse' : 'TextApiResponse'](
      response
    ) as any;
  }

  /**
   * Adds a privilege to an existing mail user.
   * Add mail user privilege
   */
  async addMailUserPrivilege(
    requestParameters: AddMailUserPrivilegeRequest
  ): Promise<string> {
    const response = await this.addMailUserPrivilegeRaw(requestParameters);
    return await response.value();
  }

  /**
   * Returns all mail aliases.
   * Get mail aliases
   */
  async getMailAliasesRaw(
    requestParameters: GetMailAliasesRequest
  ): Promise<runtime.ApiResponse<Array<MailAliasByDomain>>> {
    const queryParameters: runtime.HTTPQuery = {};

    if (requestParameters.format !== undefined) {
      queryParameters['format'] = requestParameters.format;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' +
        btoa(this.configuration.username + ':' + this.configuration.password);
    }
    const response = await this.request({
      path: `/mail/aliases`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    });

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(MailAliasByDomainFromJSON)
    );
  }

  /**
   * Returns all mail aliases.
   * Get mail aliases
   */
  async getMailAliases(
    requestParameters: GetMailAliasesRequest
  ): Promise<Array<MailAliasByDomain>> {
    const response = await this.getMailAliasesRaw(requestParameters);
    return await response.value();
  }

  /**
   * Returns all mail domains.
   * Get mail domains
   */
  async getMailDomainsRaw(): Promise<runtime.ApiResponse<string>> {
    const queryParameters: runtime.HTTPQuery = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' +
        btoa(this.configuration.username + ':' + this.configuration.password);
    }
    const response = await this.request({
      path: `/mail/domains`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    });

    const contentType = response.headers.get('content-type');
    const isJson = contentType && contentType.includes('application/json');
    return new runtime[isJson ? 'JSONApiResponse' : 'TextApiResponse'](
      response
    ) as any;
  }

  /**
   * Returns all mail domains.
   * Get mail domains
   */
  async getMailDomains(): Promise<string> {
    const response = await this.getMailDomainsRaw();
    return await response.value();
  }

  /**
   * Returns all privileges for an existing mail user.
   * Get mail user privileges
   */
  async getMailUserPrivilegesRaw(
    requestParameters: GetMailUserPrivilegesRequest
  ): Promise<runtime.ApiResponse<MailUserPrivilege>> {
    const queryParameters: runtime.HTTPQuery = {};

    if (requestParameters.email !== undefined) {
      queryParameters['email'] = requestParameters.email;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' +
        btoa(this.configuration.username + ':' + this.configuration.password);
    }
    const response = await this.request({
      path: `/mail/users/privileges`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    });

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      MailUserPrivilegeFromJSON(jsonValue)
    );
  }

  /**
   * Returns all privileges for an existing mail user.
   * Get mail user privileges
   */
  async getMailUserPrivileges(
    requestParameters: GetMailUserPrivilegesRequest
  ): Promise<MailUserPrivilege> {
    const response = await this.getMailUserPrivilegesRaw(requestParameters);
    return await response.value();
  }

  /**
   * Returns all mail users.
   * Get mail users
   */
  async getMailUsersRaw(
    requestParameters: GetMailUsersRequest
  ): Promise<runtime.ApiResponse<MailUsersResponse>> {
    const queryParameters: runtime.HTTPQuery = {};

    if (requestParameters.format !== undefined) {
      queryParameters['format'] = requestParameters.format;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' +
        btoa(this.configuration.username + ':' + this.configuration.password);
    }
    const response = await this.request({
      path: `/mail/users`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    });

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      MailUsersResponseFromJSON(jsonValue)
    );
  }

  /**
   * Returns all mail users.
   * Get mail users
   */
  async getMailUsers(
    requestParameters: GetMailUsersRequest
  ): Promise<MailUsersResponse> {
    const response = await this.getMailUsersRaw(requestParameters);
    return await response.value();
  }

  /**
   * Removes a mail alias.
   * Remove mail alias
   */
  async removeMailAliasRaw(
    requestParameters: RemoveMailAliasRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (
      requestParameters.address === null ||
      requestParameters.address === undefined
    ) {
      throw new runtime.RequiredError(
        'address',
        'Required parameter requestParameters.address was null or undefined when calling removeMailAlias.'
      );
    }

    const queryParameters: runtime.HTTPQuery = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' +
        btoa(this.configuration.username + ':' + this.configuration.password);
    }
    const consumes: runtime.Consume[] = [
      { contentType: 'application/x-www-form-urlencoded' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.address !== undefined) {
      formParams.append('address', requestParameters.address as any);
    }

    const response = await this.request({
      path: `/mail/aliases/remove`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: formParams,
    });

    const contentType = response.headers.get('content-type');
    const isJson = contentType && contentType.includes('application/json');
    return new runtime[isJson ? 'JSONApiResponse' : 'TextApiResponse'](
      response
    ) as any;
  }

  /**
   * Removes a mail alias.
   * Remove mail alias
   */
  async removeMailAlias(
    requestParameters: RemoveMailAliasRequest
  ): Promise<string> {
    const response = await this.removeMailAliasRaw(requestParameters);
    return await response.value();
  }

  /**
   * Removes an existing mail user.
   * Remove mail user
   */
  async removeMailUserRaw(
    requestParameters: RemoveMailUserRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (
      requestParameters.email === null ||
      requestParameters.email === undefined
    ) {
      throw new runtime.RequiredError(
        'email',
        'Required parameter requestParameters.email was null or undefined when calling removeMailUser.'
      );
    }

    const queryParameters: runtime.HTTPQuery = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' +
        btoa(this.configuration.username + ':' + this.configuration.password);
    }
    const consumes: runtime.Consume[] = [
      { contentType: 'application/x-www-form-urlencoded' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.email !== undefined) {
      formParams.append('email', requestParameters.email as any);
    }

    const response = await this.request({
      path: `/mail/users/remove`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: formParams,
    });

    const contentType = response.headers.get('content-type');
    const isJson = contentType && contentType.includes('application/json');
    return new runtime[isJson ? 'JSONApiResponse' : 'TextApiResponse'](
      response
    ) as any;
  }

  /**
   * Removes an existing mail user.
   * Remove mail user
   */
  async removeMailUser(
    requestParameters: RemoveMailUserRequest
  ): Promise<string> {
    const response = await this.removeMailUserRaw(requestParameters);
    return await response.value();
  }

  /**
   * Removes a privilege from an existing mail user.
   * Remove mail user privilege
   */
  async removeMailUserPrivilegeRaw(
    requestParameters: RemoveMailUserPrivilegeRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (
      requestParameters.email === null ||
      requestParameters.email === undefined
    ) {
      throw new runtime.RequiredError(
        'email',
        'Required parameter requestParameters.email was null or undefined when calling removeMailUserPrivilege.'
      );
    }

    if (
      requestParameters.privilege === null ||
      requestParameters.privilege === undefined
    ) {
      throw new runtime.RequiredError(
        'privilege',
        'Required parameter requestParameters.privilege was null or undefined when calling removeMailUserPrivilege.'
      );
    }

    const queryParameters: runtime.HTTPQuery = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' +
        btoa(this.configuration.username + ':' + this.configuration.password);
    }
    const consumes: runtime.Consume[] = [
      { contentType: 'application/x-www-form-urlencoded' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.email !== undefined) {
      formParams.append('email', requestParameters.email as any);
    }

    if (requestParameters.privilege !== undefined) {
      formParams.append('privilege', requestParameters.privilege as any);
    }

    const response = await this.request({
      path: `/mail/users/privileges/remove`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: formParams,
    });

    const contentType = response.headers.get('content-type');
    const isJson = contentType && contentType.includes('application/json');
    return new runtime[isJson ? 'JSONApiResponse' : 'TextApiResponse'](
      response
    ) as any;
  }

  /**
   * Removes a privilege from an existing mail user.
   * Remove mail user privilege
   */
  async removeMailUserPrivilege(
    requestParameters: RemoveMailUserPrivilegeRequest
  ): Promise<string> {
    const response = await this.removeMailUserPrivilegeRaw(requestParameters);
    return await response.value();
  }

  /**
   * Sets a password for an existing mail user.
   * Set mail user password
   */
  async setMailUserPasswordRaw(
    requestParameters: SetMailUserPasswordRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (
      requestParameters.email === null ||
      requestParameters.email === undefined
    ) {
      throw new runtime.RequiredError(
        'email',
        'Required parameter requestParameters.email was null or undefined when calling setMailUserPassword.'
      );
    }

    if (
      requestParameters.password === null ||
      requestParameters.password === undefined
    ) {
      throw new runtime.RequiredError(
        'password',
        'Required parameter requestParameters.password was null or undefined when calling setMailUserPassword.'
      );
    }

    const queryParameters: runtime.HTTPQuery = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' +
        btoa(this.configuration.username + ':' + this.configuration.password);
    }
    const consumes: runtime.Consume[] = [
      { contentType: 'application/x-www-form-urlencoded' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.email !== undefined) {
      formParams.append('email', requestParameters.email as any);
    }

    if (requestParameters.password !== undefined) {
      formParams.append('password', requestParameters.password as any);
    }

    const response = await this.request({
      path: `/mail/users/password`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: formParams,
    });

    const contentType = response.headers.get('content-type');
    const isJson = contentType && contentType.includes('application/json');
    return new runtime[isJson ? 'JSONApiResponse' : 'TextApiResponse'](
      response
    ) as any;
  }

  /**
   * Sets a password for an existing mail user.
   * Set mail user password
   */
  async setMailUserPassword(
    requestParameters: SetMailUserPasswordRequest
  ): Promise<string> {
    const response = await this.setMailUserPasswordRaw(requestParameters);
    return await response.value();
  }

  /**
   * Adds or updates a mail alias. If updating, you need to set `update_if_exists: 1`.
   * Upsert mail alias
   */
  async upsertMailAliasRaw(
    requestParameters: UpsertMailAliasRequest
  ): Promise<runtime.ApiResponse<string>> {
    if (
      requestParameters.updateIfExists === null ||
      requestParameters.updateIfExists === undefined
    ) {
      throw new runtime.RequiredError(
        'updateIfExists',
        'Required parameter requestParameters.updateIfExists was null or undefined when calling upsertMailAlias.'
      );
    }

    if (
      requestParameters.address === null ||
      requestParameters.address === undefined
    ) {
      throw new runtime.RequiredError(
        'address',
        'Required parameter requestParameters.address was null or undefined when calling upsertMailAlias.'
      );
    }

    if (
      requestParameters.forwardsTo === null ||
      requestParameters.forwardsTo === undefined
    ) {
      throw new runtime.RequiredError(
        'forwardsTo',
        'Required parameter requestParameters.forwardsTo was null or undefined when calling upsertMailAlias.'
      );
    }

    if (
      requestParameters.permittedSenders === null ||
      requestParameters.permittedSenders === undefined
    ) {
      throw new runtime.RequiredError(
        'permittedSenders',
        'Required parameter requestParameters.permittedSenders was null or undefined when calling upsertMailAlias.'
      );
    }

    const queryParameters: runtime.HTTPQuery = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters['Authorization'] =
        'Basic ' +
        btoa(this.configuration.username + ':' + this.configuration.password);
    }
    const consumes: runtime.Consume[] = [
      { contentType: 'application/x-www-form-urlencoded' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.updateIfExists !== undefined) {
      formParams.append(
        'update_if_exists',
        requestParameters.updateIfExists as any
      );
    }

    if (requestParameters.address !== undefined) {
      formParams.append('address', requestParameters.address as any);
    }

    if (requestParameters.forwardsTo !== undefined) {
      formParams.append('forwards_to', requestParameters.forwardsTo as any);
    }

    if (requestParameters.permittedSenders !== undefined) {
      formParams.append(
        'permitted_senders',
        requestParameters.permittedSenders as any
      );
    }

    const response = await this.request({
      path: `/mail/aliases/add`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: formParams,
    });

    const contentType = response.headers.get('content-type');
    const isJson = contentType && contentType.includes('application/json');
    return new runtime[isJson ? 'JSONApiResponse' : 'TextApiResponse'](
      response
    ) as any;
  }

  /**
   * Adds or updates a mail alias. If updating, you need to set `update_if_exists: 1`.
   * Upsert mail alias
   */
  async upsertMailAlias(
    requestParameters: UpsertMailAliasRequest
  ): Promise<string> {
    const response = await this.upsertMailAliasRaw(requestParameters);
    return await response.value();
  }
}
